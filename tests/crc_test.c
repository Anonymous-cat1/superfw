/*
 * Copyright (C) 2024 David Guillen Fandos <david@davidgf.net>
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "crc.h"

int main() {
  const struct {
    const char *data;
    const uint8_t len;
    const uint8_t pad_value;
    const uint8_t crcout[8];
  } testvec[] = {
    {
      "", 0, 0,
      {0,0,0,0,0,0,0,0},
    },
    {
      "", 0, 0xFF,
      {0xff, 0xf0, 0xff, 0x0f, 0xf0, 0xf0, 0xf0, 0x0f},
    },
    {
      "", 0, 0x55,
      {0x55, 0x50, 0x55, 0x05, 0x50, 0x50, 0x50, 0x05},
    },
    {
      "test text", 9, 0,
      {0x32, 0x9f, 0x49, 0xc7, 0xde, 0x67, 0x7c, 0x01},
    },
    {
      "testtesttesttesttesttesttesttest", 32, 0,
      {0x47, 0x13, 0x52, 0x70, 0x61, 0x41, 0x64, 0x67},
    },
  };

  for (unsigned i = 0; i < sizeof(testvec)/sizeof(testvec[0]); i++) {
    uint8_t co[8], co2[8], co3[8], co4[8];
    uint8_t idata[512];
    for (unsigned j = 0; j < sizeof(idata); j++)
      idata[j] = testvec[i].pad_value;

    memcpy(idata, testvec[i].data, testvec[i].len);
    crc16_nibble_512(idata, co);
    crc16_nibble_512_8bit(idata, co2);
    crc16_nibble_512_nolut(idata, co3);
    crc16_nibble_512_nolut8bit(idata, co4);
    assert(!memcmp(co,  testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co2, testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co3, testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co4, testvec[i].crcout, sizeof(testvec[i].crcout)));
  }

  // Unaligned buffer
  for (unsigned i = 0; i < sizeof(testvec)/sizeof(testvec[0]); i++) {
    uint8_t co[8], co2[8], co3[8], co4[8];
    uint8_t idata[513];
    for (unsigned j = 0; j < sizeof(idata); j++)
      idata[j] = testvec[i].pad_value;

    memcpy(&idata[1], testvec[i].data, testvec[i].len);
    crc16_nibble_512(&idata[1], co);
    crc16_nibble_512_8bit(&idata[1], co2);
    crc16_nibble_512_nolut(&idata[1], co3);
    crc16_nibble_512_nolut8bit(&idata[1], co4);
    assert(!memcmp(co,  testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co2, testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co3, testvec[i].crcout, sizeof(testvec[i].crcout)));
    assert(!memcmp(co4, testvec[i].crcout, sizeof(testvec[i].crcout)));
  }

  const struct {
    const char *data;
    const uint8_t len;
    const uint8_t crcv;
  } testvec7[] = {
    {
      "TTTTT", 5, 0x2E | 1
    },
    {
      "deadbeef", 8, 0x20 | 1
    },
    {
      "\x00\x00\x00\x00\x00\x00\x00\x00", 8, 0 | 1
    },
    {
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8, 0xD6 | 1
    },
    {
      "\x00\x01\x02\x03\x04\x05\x06", 7, 0xEE | 1
    },
  };

  for (unsigned i = 0; i < sizeof(testvec7)/sizeof(testvec7[0]); i++) {
    uint8_t ret = crc7((uint8_t*)testvec7[i].data, testvec7[i].len);
    uint8_t ret2 = crc7_nolut((uint8_t*)testvec7[i].data, testvec7[i].len);
    assert(ret  == testvec7[i].crcv);
    assert(ret2 == testvec7[i].crcv);
  }

  // Example NDS header
  const uint8_t tsthdr[] = {
    0x48,0x4f,0x4d,0x45,0x42,0x52,0x45,0x57,
    0x00,0x00,0x00,0x00,0x23,0x23,0x23,0x23,
    0x00,0x00,0x02,0x00,0x01,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
    0x00,0x40,0x00,0x00,0x00,0x08,0x00,0x02,
    0x00,0x00,0x00,0x02,0x18,0x5d,0x01,0x00,
    0x00,0x9e,0x01,0x00,0x00,0x00,0x38,0x02,
    0x00,0x00,0x38,0x02,0xa4,0xae,0x00,0x00,
    0x00,0x4e,0x02,0x00,0x09,0x00,0x00,0x00,
    0x00,0x50,0x02,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x60,0x58,0x00,0xf8,0x08,0x18,0x00,
    0x00,0x50,0x02,0x00,0xfc,0x59,0x1e,0x05,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x58,0x02,0x00,0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x24,0xff,0xae,0x51,0x69,0x9a,0xa2,0x21,
    0x3d,0x84,0x82,0x0a,0x84,0xe4,0x09,0xad,
    0x11,0x24,0x8b,0x98,0xc0,0x81,0x7f,0x21,
    0xa3,0x52,0xbe,0x19,0x93,0x09,0xce,0x20,
    0x10,0x46,0x4a,0x4a,0xf8,0x27,0x31,0xec,
    0x58,0xc7,0xe8,0x33,0x82,0xe3,0xce,0xbf,
    0x85,0xf4,0xdf,0x94,0xce,0x4b,0x09,0xc1,
    0x94,0x56,0x8a,0xc0,0x13,0x72,0xa7,0xfc,
    0x9f,0x84,0x4d,0x73,0xa3,0xca,0x9a,0x61,
    0x58,0x97,0xa3,0x27,0xfc,0x03,0x98,0x76,
    0x23,0x1d,0xc7,0x61,0x03,0x04,0xae,0x56,
    0xbf,0x38,0x84,0x00,0x40,0xa7,0x0e,0xfd,
    0xff,0x52,0xfe,0x03,0x6f,0x95,0x30,0xf1,
    0x97,0xfb,0xc0,0x85,0x60,0xd6,0x80,0x25,
    0xa9,0x63,0xbe,0x03,0x01,0x4e,0x38,0xe2,
    0xf9,0xa2,0x34,0xff,0xbb,0x3e,0x03,0x44,
    0x78,0x00,0x90,0xcb,0x88,0x11,0x3a,0x94,
    0x65,0xc0,0x7c,0x63,0x87,0xf0,0x3c,0xaf,
    0xd6,0x25,0xe4,0x8b,0x38,0x0a,0xac,0x72,
    0x21,0xd4,0xf8,0x07,0x56,0xcf,
  };
  assert(ds_crc16(tsthdr, sizeof(tsthdr)) == 0x544a);
}


